/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => SmarterMDhotkeys
});

// const.ts
var COMMANDS = [
  {
    id: "smarter-asterisk-bold",
    name: "Smarter Bold",
    before: "**",
    after: "**"
  },
  {
    id: "smarter-underscore-bold",
    name: "Smarter Underscore Bold",
    before: "__",
    after: "__"
  },
  {
    id: "smarter-asterisk-italics",
    name: "Smarter Italics",
    before: "*",
    after: "*"
  },
  {
    id: "smarter-underscore-italics",
    name: "Smarter Underscore Italics",
    before: "_",
    after: "_"
  },
  {
    id: "smarter-comments",
    name: "Smarter Comments",
    before: "%%",
    after: "%%"
  },
  {
    id: "smarter-inline-code",
    name: "Smarter Inline Code",
    before: "`",
    after: "`"
  },
  {
    id: "smarter-highlight",
    name: "Smarter Highlight",
    before: "==",
    after: "=="
  },
  {
    id: "smarter-strikethrough",
    name: "Smarter Strikethrough",
    before: "~~",
    after: "~~"
  },
  {
    id: "smarter-wikilink",
    name: "Smarter wikilink (internal link)",
    before: "[[",
    after: "]]"
  },
  {
    id: "smarter-md-link",
    name: "Smarter Markdown Link",
    before: "[",
    after: "]()"
  }
];

// main.ts
var import_obsidian = __toModule(require("obsidian"));
var SmarterMDhotkeys = class extends import_obsidian.Plugin {
  onload() {
    return __async(this, null, function* () {
      COMMANDS.forEach((command) => {
        const { id, name, before, after } = command;
        this.addCommand({
          id,
          name,
          editorCallback: (editor) => this.expandAndWrap(before, after, editor)
        });
      });
      console.log("Smarter MD Hotkeys loaded.");
    });
  }
  onunload() {
    return __async(this, null, function* () {
      console.log("Smarter MD Hotkeys unloaded.");
    });
  }
  expandAndWrap(frontMarkup, endMarkup, editor) {
    const [blen, alen] = [frontMarkup.length, endMarkup.length];
    const debug = true;
    function markupOutsideSel() {
      const so = startOffset();
      const eo = endOffset();
      const charsBefore = editor.getRange(offToPos(so - blen), offToPos(so));
      const charsAfter = editor.getRange(offToPos(eo), offToPos(eo + alen));
      return charsBefore === frontMarkup && charsAfter === endMarkup;
    }
    const nothingSelected = () => !editor.somethingSelected();
    const multiWordSel = () => editor.getSelection().includes(" ");
    const multiLineSel = () => editor.getSelection().includes("\n");
    const partialWordSel = () => !nothingSelected() && !multiWordSel() && !multiLineSel();
    const startOffset = () => editor.posToOffset(editor.getCursor("from"));
    const endOffset = () => editor.posToOffset(editor.getCursor("to"));
    const offToPos = (offset) => editor.offsetToPos(offset);
    function log(msg, appendSelection) {
      if (!debug)
        return;
      let appended = "";
      if (appendSelection)
        appended = ": " + editor.getSelection();
      console.log("- " + msg + appended);
    }
    function textUnderCursor(ep) {
      function wordUnderCursor(ep_) {
        var _a, _b;
        if ((_a = editor.cm) == null ? void 0 : _a.findWordAt)
          return editor.cm.findWordAt(ep);
        if ((_b = editor.cm) == null ? void 0 : _b.state.wordAt)
          return editor.cm.state.wordAt(editor.posToOffset(ep));
      }
      function codeUnderCursor(ep_) {
        const so = editor.posToOffset(editor.getCursor("from"));
        let charAfter, charBefore;
        let [i, j, endReached, startReached] = [0, 0, false, false];
        const noteLength = editor.getValue().length;
        while (!/\s/.test(charBefore) && !startReached) {
          charBefore = editor.getRange(offToPos(so - (i + 1)), offToPos(so - i));
          i++;
          if (so - (i - 1) === 0)
            startReached = true;
        }
        while (!/\s/.test(charAfter) && !endReached) {
          charAfter = editor.getRange(offToPos(so + j), offToPos(so + j + 1));
          j++;
          if (so + (j - 1) === noteLength)
            endReached = true;
        }
        return { anchor: offToPos(so - (i - 1)), head: offToPos(so + (j - 1)) };
      }
      if (frontMarkup === "`")
        return codeUnderCursor(ep);
      return wordUnderCursor(ep);
    }
    function trimSelection() {
      const trimBefore = ["- [ ] ", "- [x] ", "- ", " ", "\n", "	", frontMarkup];
      const trimAfter = [" ", "\n", "	", endMarkup];
      let selection = editor.getSelection();
      let so = startOffset();
      log("before trim", true);
      let trimFinished = false;
      while (!trimFinished) {
        let cleanCount = 0;
        trimBefore.forEach((str) => {
          if (selection.startsWith(str)) {
            selection = selection.slice(str.length);
            so += str.length;
          } else {
            cleanCount++;
          }
        });
        if (cleanCount === trimBefore.length || !selection.length)
          trimFinished = true;
      }
      trimFinished = false;
      while (!trimFinished) {
        let cleanCount = 0;
        trimAfter.forEach((str) => {
          if (selection.endsWith(str))
            selection = selection.slice(0, -str.length);
          else
            cleanCount++;
        });
        if (cleanCount === trimAfter.length || !selection.length)
          trimFinished = true;
      }
      const blockID = selection.match(/ \^\w+$/);
      if (blockID)
        selection = selection.slice(0, -blockID[0].length);
      editor.setSelection(offToPos(so), offToPos(so + selection.length));
      log("after trim", true);
    }
    function expandToWordBoundary() {
      let prePartialWordExpAnchor, prePartialWordExpHead;
      log("before Exp to Word", true);
      if (partialWordSel()) {
        log("One Word Expansion");
        prePartialWordExpAnchor = editor.getCursor("from");
        prePartialWordExpHead = editor.getCursor("to");
        const { anchor, head } = textUnderCursor(prePartialWordExpAnchor);
        const word = editor.getRange(anchor, head);
        if (/^[.,;:\-–—]/.test(word))
          head.ch = anchor.ch + 1;
        editor.setSelection(anchor, head);
      }
      let preMultiWordExpAnchor, preMultiWordExpHead;
      if (multiWordSel()) {
        log("Multi-Word Expansion");
        preMultiWordExpAnchor = editor.getCursor("from");
        preMultiWordExpHead = editor.getCursor("to");
        const firstWordRange = textUnderCursor(preMultiWordExpAnchor);
        preMultiWordExpHead.ch--;
        const lastWordRange = textUnderCursor(preMultiWordExpHead);
        preMultiWordExpHead.ch++;
        const lastWord = editor.getRange(lastWordRange.anchor, lastWordRange.head);
        if (/^[.,;:\-–—]/.test(lastWord))
          lastWordRange.head.ch = lastWordRange.anchor.ch + 1;
        editor.setSelection(firstWordRange.anchor, lastWordRange.head);
      }
      log("after expansion", true);
      trimSelection();
      return [prePartialWordExpAnchor, prePartialWordExpHead, preMultiWordExpAnchor, preMultiWordExpHead];
    }
    function applyMarkup(preNothingExpPos_, prePartialWordExpAnchor_, prePartialWordExpHead_, preMultiWordExpAnchor_, preMultiWordExpHead_, mode) {
      const selectedText = editor.getSelection();
      const so = startOffset();
      const eo = endOffset();
      if (nothingSelected() && mode === "multi")
        return;
      if (nothingSelected()) {
        editor.replaceSelection(frontMarkup + endMarkup);
        const cursor = editor.getCursor();
        cursor.ch -= alen;
        editor.setCursor(cursor);
        return;
      }
      if (!markupOutsideSel() && !nothingSelected()) {
        editor.replaceSelection(frontMarkup + selectedText + endMarkup);
        if (preNothingExpPos_) {
          const pos = preNothingExpPos_;
          pos.ch += blen;
          editor.setCursor(pos);
          return;
        }
        let anchor, head;
        if (preMultiWordExpAnchor_) {
          anchor = preMultiWordExpAnchor_;
          head = preMultiWordExpHead_;
          anchor.ch += blen;
          head.ch += alen;
        } else if (prePartialWordExpAnchor_) {
          anchor = prePartialWordExpAnchor_;
          head = prePartialWordExpHead_;
          anchor.ch += blen;
          head.ch += blen;
        } else {
          anchor = offToPos(so + blen);
          head = offToPos(eo + blen);
        }
        if (mode === "single")
          editor.setSelection(anchor, head);
        return;
      }
      if (markupOutsideSel() && !nothingSelected()) {
        editor.setSelection(offToPos(so - blen), offToPos(eo + alen));
        editor.replaceSelection(selectedText);
        if (preNothingExpPos_) {
          const pos = preNothingExpPos_;
          pos.ch -= blen;
          editor.setCursor(pos);
          return;
        }
        let anchor, head;
        if (preMultiWordExpAnchor_) {
          anchor = preMultiWordExpAnchor_;
          head = preMultiWordExpHead_;
          anchor.ch -= blen;
          head.ch -= alen;
        } else if (prePartialWordExpAnchor_) {
          anchor = prePartialWordExpAnchor_;
          head = prePartialWordExpHead_;
          anchor.ch -= blen;
          head.ch -= alen;
        } else {
          anchor = offToPos(so - blen);
          head = offToPos(eo - alen);
        }
        if (mode === "single")
          editor.setSelection(anchor, head);
        return;
      }
    }
    if (debug) {
      console.log("");
      console.log("SmartMD triggered.");
      console.log("------------------");
    }
    if (nothingSelected() && markupOutsideSel()) {
      const so = startOffset();
      const eo = endOffset();
      editor.setSelection(offToPos(so - blen), offToPos(eo + alen));
      editor.replaceSelection("");
      editor.setSelection(offToPos(so - blen), offToPos(eo - alen));
      return;
    }
    let preNothingExpPos;
    if (nothingSelected() && !markupOutsideSel()) {
      preNothingExpPos = editor.getCursor();
      const { anchor, head } = textUnderCursor(preNothingExpPos);
      editor.setSelection(anchor, head);
    }
    trimSelection();
    if (multiLineSel()) {
      let pointerOff = startOffset();
      const lines = editor.getSelection().split("\n");
      log("lines: " + lines.length.toString());
      lines.forEach((line) => {
        console.log("");
        const lineStartOff = pointerOff;
        const lineEndOff = pointerOff + line.length;
        editor.setSelection(offToPos(lineStartOff), offToPos(lineEndOff));
        const preExpPositions = expandToWordBoundary();
        pointerOff += line.length + 1;
        if (markupOutsideSel())
          pointerOff -= blen + alen;
        else
          pointerOff += blen + alen;
        applyMarkup(preNothingExpPos, ...preExpPositions, "multi");
      });
    } else {
      log("single line");
      const preExpPositions = expandToWordBoundary();
      applyMarkup(preNothingExpPos, ...preExpPositions, "single");
    }
  }
};
